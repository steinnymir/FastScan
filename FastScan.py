# -*- coding: utf-8 -*-
"""

@author: Steinn Ymir Agustsson

    Copyright (C) 2018 Steinn Ymir Agustsson

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
import os
import sys
from multiprocessing import Pool

import nidaqmx
import numpy as np
import pyqtgraph as pg
from PyQt5.QtCore import QCoreApplication, QTimer
from PyQt5.QtWidgets import QMainWindow, QApplication, QWidget, QGridLayout, QHBoxLayout, QVBoxLayout, QPushButton, \
    QGroupBox,QSpinBox
from nidaqmx.constants import Edge, AcquisitionType
from nidaqmx import stream_readers
from pyqtgraph.Qt import QtCore, QtGui

from utilities.data import bin_dc_multi


def main():
    from utilities.qt import my_exception_hook
    # used to see errors generated by PyQt5 in pycharm:
    sys._excepthook = sys.excepthook
    # Set the exception hook to our wrapping function
    sys.excepthook = my_exception_hook

    app = QCoreApplication.instance()
    if app is None:
        app = QApplication(sys.argv)
    # Create handle prg for the Graphic Interface
    prg = FastScanMainWindow()
    # prg = testwindow()

    # print('showing GUI')
    prg.show()

    try:
        app.exec_()
    except:
        print('exiting')


class testwindow(QMainWindow):

    def __init__(self):
        super(testwindow, self).__init__()
        hbox = QtGui.QHBoxLayout(self)

        topleft = QtGui.QFrame(self)
        topleft.setFrameShape(QtGui.QFrame.StyledPanel)
        topleft.setGeometry(0, 0, 300, 0)

        topright = QtGui.QFrame(self)
        topright.setFrameShape(QtGui.QFrame.StyledPanel)
        topright.setGeometry(0, 320, 1000, 0)

        bottom = QtGui.QFrame(self)
        bottom.setFrameShape(QtGui.QFrame.StyledPanel)
        bottom.setGeometry(1210, 0, 1280, 0)

        splitter1 = QtGui.QSplitter(QtCore.Qt.Horizontal)
        splitter1.addWidget(topleft)
        splitter1.addWidget(topright)

        splitter2 = QtGui.QSplitter(QtCore.Qt.Vertical)
        splitter2.addWidget(splitter1)
        splitter2.addWidget(bottom)

        hbox.addWidget(splitter2)

        self.setLayout(hbox)
        # QtGui.QApplication.setStyle(QtGui.QStyleFactory.create('Cleanlooks'))


class FastScanMainWindow(QMainWindow):
    _SIMULATE = True

    def __init__(self):
        super(FastScanMainWindow, self).__init__()
        self.setWindowTitle('Fast Scan')
        self.setGeometry(100, 50, 1152, 768)

        self.status_bar = self.statusBar()
        self.status_bar.showMessage('ready')

        # set the cool dark theme and other plotting settings
        # self.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())
        pg.setConfigOption('background', .1)
        pg.setConfigOption('foreground', .9)
        pg.setConfigOptions(antialias=True)
        self.setupUi()

        #########################
        #   define variables    #
        #########################
        self.main_clock = QTimer()
        self.set_clock_frequency(2)
        self.main_clock.timeout.connect(self.on_timer)
        self.main_clock_running = False

        self.laser_trigger_frequency = 273000
        self.shaker_frequency = 10
        self.n_periods = 1

        self.n_samples = int((self.laser_trigger_frequency / self.shaker_frequency) * self.n_periods)

        self.bins = None
        self.n_bins = 1000
        self.bin_cutoff = .02

    def setupUi(self):
        central_widget = QWidget(self)
        self.setCentralWidget(central_widget)
        central_layout = QHBoxLayout()
        central_widget.setLayout(central_layout)

        verticalSpacer = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)

        control_widget = QWidget()
        central_layout.addWidget(control_widget)

        control_layout = QVBoxLayout()
        control_widget.setLayout(control_layout)
        visual_widget = QWidget()
        central_layout.addWidget(visual_widget)

        visual_layout = QGridLayout()
        visual_widget.setLayout(visual_layout)

        self.plot_area = pg.PlotWidget(name='plot')
        visual_layout.addWidget(self.plot_area, 0, 0, 5, 5)
        self.plot = self.plot_area.plot()
        self.plot.setPen(pg.mkPen(255, 255, 255))
        self.plot_area.setLabel('left', 'Value', units='V')
        self.plot_area.setLabel('bottom', 'Time', units='s')

        box_cont = QGroupBox('continuous acquisition')
        control_layout.addWidget(box_cont)
        box_cont_layout = QGridLayout()
        box_cont.setLayout(box_cont_layout)

        self.start_button = QPushButton('start')
        box_cont_layout.addWidget(self.start_button, 0, 0, 1, 1)
        self.start_button.clicked.connect(self.start_continuous_acquisition)
        self.stop_button = QPushButton('stop')
        box_cont_layout.addWidget(self.stop_button, 0, 1, 1, 1)
        self.stop_button.clicked.connect(self.stop_continuous_acquisition)


        box_finite = QGroupBox('finite acquisition')
        control_layout.addWidget(box_finite)
        box_finite_layout = QGridLayout()
        box_finite.setLayout(box_finite_layout)

        self.iterations_spinbox = QSpinBox()
        box_finite_layout.addWidget(self.iterations_spinbox, 0, 0, 1, 1)
        self.iterations_spinbox.setMinimum(1)
        self.finite_iterations = 10

        self.iterations_spinbox.setValue(self.finite_iterations)
        self.iterations_spinbox.valueChanged.connect(self.set_iteration_number)
        self.start_finite_button = QPushButton('Go!')
        box_finite_layout.addWidget(self.start_finite_button, 0, 1, 1, 1)
        self.start_finite_button.clicked.connect(self.start_finite_acquisition)

    def setupUi_old(self):
        self.central_widget = QWidget(self)
        self.setCentralWidget(self.central_widget)
        self.central_layout = QHBoxLayout()
        self.central_widget.setLayout(self.central_layout)
        # self.main_layout = QGridLayout(self)
        # self.central_widget.setLayout(self.main_layout)

        self.control_widget = QWidget()
        self.central_layout.addWidget(self.control_widget)
        self.control_layout = QVBoxLayout()
        self.control_widget.setLayout(self.control_layout)
        self.visual_widget = QWidget()
        self.central_layout.addWidget(self.visual_widget)

        self.visual_layout = QGridLayout()
        self.visual_widget.setLayout(self.visual_layout)

        self.plot_area = pg.PlotWidget(name='plot')
        self.visual_layout.addWidget(self.plot_area, 0, 0, 5, 5)
        self.setup_plot_area()

        self.controlbox = QGroupBox('controls')
        self.control_layout.addWidget(self.controlbox)
        self.controlbox_layout = QGridLayout()
        self.controlbox.setLayout(self.controlbox_layout)

        self.start_stop_button = QPushButton('start/stop')
        self.controlbox_layout.addWidget(self.start_stop_button, 0, 0, 1, 1)
        self.start_stop_button.clicked.connect(self.start_stop_timer)
        #
        # self.fit_checkbox = QRadioButton('fit')
        # self.controlbox_layout.addWidget(self.fit_checkbox, 1, 0, 1, 1)
        # self.fit_button = QPushButton('force refit')
        # self.controlbox_layout.addWidget(self.fit_button, 1, 1, 1, 1)
        # self.fit_button.clicked.connect(self.fit_peaks)
        #
        # self.resultsbox = QGroupBox('Fit Results')
        # self.main_layout.addWidget(self.resultsbox, 1, 3, 1, 2)
        # self.resultsbox_layout = QGridLayout()
        # self.resultsbox.setLayout(self.resultsbox_layout)
        #
        # self.fit_results_text = QLabel('Start fitting to show results')
        # self.fit_results_text.setFont(QFont("Times", 8, QFont.Bold))
        # self.resultsbox_layout.addWidget(self.fit_results_text, 0, 0)
        # self.fit_mainresults_text = QLabel('')
        # self.fit_mainresults_text.setFont(QFont("Times", 12, QFont.Bold))
        # self.resultsbox_layout.addWidget(self.fit_mainresults_text, 0, 1)
        #
        # # self.plt_widget = MatplotlibWidget.MatplotlibWidget()
        # # self.main_layout.addWidget(self.plt_widget,0,0,5,5)
        # # self.subplot = self.plt_widget.getFigure().add_subplot(111)

    def make_bins(self, data, n_bins=1000, cutoff=.02):
        dmax, dmin = data[0].max(), data[0].min()
        amp = dmax - dmin
        dmax -= amp * cutoff
        dmin += amp * cutoff
        self.bins = np.linspace(dmin, dmax, n_bins)

    def set_iteration_number(self,n):
        self.finite_iterations = n

    def set_clock_frequency(self, frequency=2):
        self.main_clock.setInterval(1. / frequency)

    def start_stop_timer(self):
        if self.main_clock_running:
            self.main_clock.stop()
            self.main_clock_running = False
            self.status_bar.showMessage('Main Clock Started')
        else:
            self.main_clock.start()
            self.main_clock_running = True
            self.status_bar.showMessage('Main Clock Stopped')

    def on_timer(self):
        shaker_position, signal, n = self.measure()
        self.draw_plot(n, shaker_position)

    def start_continuous_acquisition(self):
        self.streamer_thread = QtCore.QThread()

        self.streamer = Streamer(self.n_samples)
        self.streamer.newData[np.ndarray].connect(self.on_streamer_data)
        self.streamer.error.connect(self.on_thread_error)
        self.streamer.moveToThread(self.streamer_thread)
        self.streamer_thread.started.connect(self.streamer.start_acquisition)
        self.streamer_thread.start()

    def stop_continuous_acquisition(self):
        print('attempting to stop thread')
        self.streamer.stop_acquisition()
        self.streamer.kill()


    def start_finite_acquisition(self):
        self.streamer_thread = QtCore.QThread()

        self.streamer = Streamer(self.n_samples,self.finite_iterations)
        self.streamer.newData[np.ndarray].connect(self.on_streamer_data)
        self.streamer.error.connect(self.on_thread_error)
        self.streamer.finished.connect(self.stop_finite_acquisition)
        self.streamer.moveToThread(self.streamer_thread)
        self.streamer_thread.started.connect(self.streamer.start_acquisition)
        self.streamer_thread.start()

    def stop_finite_acquisition(self):
        self.streamer.kill()
        del self.streamer
        del self.streamer_thread

    def bin_data(self, data):
        if self.bins is None:
            self.make_bins(data)
        self.binner_thread = QtCore.QThread()
        self.binner = Streamer(self.n_samples)
        self.binner.newData[np.ndarray].connect(self.on_binner_data)
        self.binner.error[list].connect(self.on_thread_error)
        self.binner.moveToThread(self.binner_thread)
        self.binner_thread.started.connect(self.binner.work)
        self.binner_thread.start()

    def on_thread_error(self,e):
        print(e)

    def draw_plot(self, xd, yd):
        self.plot.setData(x=xd, y=yd)

    @QtCore.pyqtSlot(np.ndarray)
    def on_streamer_data(self, data):
        print('data recieved')
        self.status_bar.showMessage('recieved Data')
        self.draw_plot(np.linspace(0,len(data[0])-1,len(data[0])),data[1])
        # self.bin_data(data)

    @QtCore.pyqtSlot()
    def on_binner_data(self, data):
        self.draw_plot(self.bins, data)

    def closeEvent(self, event):
        # geometry = self.saveGeometry()
        # self.qsettings.setValue('geometry', geometry)
        super(FastScanMainWindow, self).closeEvent(event)
        print('quitted properly')


class Streamer(QtCore.QObject):
    finished = QtCore.pyqtSignal()
    newData = QtCore.pyqtSignal(np.ndarray)
    error = QtCore.pyqtSignal(list)
    # progressChanged = QtCore.pyqtSignal(float)
    # stateChanged = QtCore.pyqtSignal(str)

    def __init__(self, n_samples, iterations=None):
        super().__init__()

        self.n_samples = n_samples
        self.iterations = iterations
        self.data = np.zeros((3, n_samples))

        # self.task = nidaqmx.Task()
        # self.reader = stream_readers.AnalogMultiChannelReader(self.task.in_stream)
        # self.task.ai_channels.add_ai_voltage_chan("Dev1/ai0")  # shaker position chanel
        # self.task.ai_channels.add_ai_voltage_chan("Dev1/ai1")  # signal chanel
        # self.task.ai_channels.add_ai_voltage_chan("Dev1/ai2")  # dark control chanel
        # self.task.timing.cfg_samp_clk_timing(1000000, source="/Dev1/PFI0",
        #                                      active_edge=Edge.RISING,
        #                                      sample_mode=AcquisitionType.CONTINUOUS)
        self.acquire = False

    def on_error(self,e):
        self.error.emit(list(e))

    @QtCore.pyqtSlot()
    def start_acquisition(self):
        try:
            with nidaqmx.Task() as task:

                self.reader = stream_readers.AnalogMultiChannelReader(task.in_stream)
                print('reader initialized')
                task.ai_channels.add_ai_voltage_chan("Dev1/ai0")  # shaker position chanel
                task.ai_channels.add_ai_voltage_chan("Dev1/ai1")  # signal chanel
                task.ai_channels.add_ai_voltage_chan("Dev1/ai2")  # dark control chanel
                print('added tasks')
                task.timing.cfg_samp_clk_timing(1000000, source="/Dev1/PFI0",
                                                     active_edge=Edge.RISING,
                                                     sample_mode=AcquisitionType.CONTINUOUS)
                task.start()
                print('started tasks')

                self.acquire = True
                if self.iterations is None:
                    i=0
                    while self.acquire:
                        i+=1
                        print('measuring cycle {}'.format(i))

                        self.measure()
                else:
                    for i in range(self.iterations):
                        self.measure()
                    self.stop_acquisition()
        except Exception as e:
            self.on_error(e)


    @QtCore.pyqtSlot()
    def stop_acquisition(self):
        print('thread got message to stop')
        if self.acquire:
            self.acquire = False
            print('scheduled to stop')
            self.finished.emit()

    def measure(self):
        self.reader.read_many_sample(self.data, number_of_samples_per_channel=self.n_samples)
        print('reader wrote data: {}'.format(self.data.mean()))
        self.newData.emit(self.data)

    @QtCore.pyqtSlot()
    def work(self):
        self.acquire = True

    @QtCore.pyqtSlot()
    def kill(self):
        print('thread killed')

    def __exit__(self):
        self.kill()


class Binner(QtCore.QObject):
    newData = QtCore.pyqtSignal(np.ndarray)
    error = QtCore.pyqtSignal(list)

    def __init__(self, data, bins):
        super().__init__()
        self.data_input = data
        self.bins = bins
        self.data_output = np.zeros_like(bins)
        self.bin_method = bin_dc_multi

    @QtCore.pyqtSlot()
    def work(self):
        try:
            chunks = os.cpu_count()-2
            data_split = np.split(self.data, chunks, axis=1)
            args = []
            for data in data_split:
                args.append((data, self.bins))
            pool = Pool(chunks)
            results = pool.map(self.bin_method, args)
            results = np.array(results)

            binned_signal = []
            normarray = []

            for i in range(8):
                binned_signal.append(results[i, 0, :])
                normarray.append(results[i, 1, :])
            binned_signal = np.nansum(np.array(binned_signal), 0)
            normarray = np.nansum(np.array(normarray), 0)

            self.data_output = binned_signal / normarray
            self.newData.emit(self.data_output)
        except Exception as e:
            self.error.emit(list[e])


if __name__ == '__main__':
    main()
