# -*- coding: utf-8 -*-
"""

@author: Steinn Ymir Agustsson

    Copyright (C) 2018 Steinn Ymir Agustsson

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
import os
import sys
from multiprocessing import Pool

import nidaqmx
import numpy as np
import pyqtgraph as pg
from PyQt5.QtCore import QCoreApplication, QTimer
from PyQt5.QtWidgets import QMainWindow, QApplication, QWidget, QGridLayout, QHBoxLayout, QVBoxLayout, QPushButton, \
    QGroupBox,QSpinBox
from nidaqmx.constants import Edge, AcquisitionType
from pyqtgraph.Qt import QtCore, QtGui

from utilities.data import bin_dc_multi


def main():
    from utilities.qt import my_exception_hook
    # used to see errors generated by PyQt5 in pycharm:
    sys._excepthook = sys.excepthook
    # Set the exception hook to our wrapping function
    sys.excepthook = my_exception_hook

    app = QCoreApplication.instance()
    if app is None:
        app = QApplication(sys.argv)
    # Create handle prg for the Graphic Interface
    prg = FastScanMainWindow()
    # prg = testwindow()

    # print('showing GUI')
    prg.show()

    try:
        app.exec_()
    except:
        print('exiting')


class testwindow(QMainWindow):

    def __init__(self):
        super(testwindow, self).__init__()
        hbox = QtGui.QHBoxLayout(self)

        topleft = QtGui.QFrame(self)
        topleft.setFrameShape(QtGui.QFrame.StyledPanel)
        topleft.setGeometry(0, 0, 300, 0)

        topright = QtGui.QFrame(self)
        topright.setFrameShape(QtGui.QFrame.StyledPanel)
        topright.setGeometry(0, 320, 1000, 0)

        bottom = QtGui.QFrame(self)
        bottom.setFrameShape(QtGui.QFrame.StyledPanel)
        bottom.setGeometry(1210, 0, 1280, 0)

        splitter1 = QtGui.QSplitter(QtCore.Qt.Horizontal)
        splitter1.addWidget(topleft)
        splitter1.addWidget(topright)

        splitter2 = QtGui.QSplitter(QtCore.Qt.Vertical)
        splitter2.addWidget(splitter1)
        splitter2.addWidget(bottom)

        hbox.addWidget(splitter2)

        self.setLayout(hbox)
        # QtGui.QApplication.setStyle(QtGui.QStyleFactory.create('Cleanlooks'))


class FastScanMainWindow(QMainWindow):
    _SIMULATE = True

    def __init__(self):
        super(FastScanMainWindow, self).__init__()
        self.setWindowTitle('Fast Scan')
        self.setGeometry(100, 50, 1152, 768)

        self.status_bar = self.statusBar()
        self.status_bar.showMessage('ready')

        # set the cool dark theme and other plotting settings
        # self.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())
        pg.setConfigOption('background', .1)
        pg.setConfigOption('foreground', .9)
        pg.setConfigOptions(antialias=True)
        self.setupUi()

        #########################
        #   define variables    #
        #########################
        self.main_clock = QTimer()
        self.set_clock_frequency(2)
        self.main_clock.timeout.connect(self.on_timer)
        self.main_clock_running = False

        self.laser_trigger_frequency = 273000
        self.shaker_frequency = 10
        self.n_periods = 10

        self.n_samples = int((self.laser_trigger_frequency / self.shaker_frequency) * self.n_periods)

        self.bins = None
        self.n_bins = 1000
        self.bin_cutoff = .02

    def setupUi(self):
        central_widget = QWidget(self)
        self.setCentralWidget(central_widget)
        central_layout = QHBoxLayout()
        central_widget.setLayout(central_layout)

        verticalSpacer = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)

        control_widget = QWidget()
        central_layout.addWidget(control_widget)

        control_layout = QVBoxLayout()
        control_widget.setLayout(control_layout)
        visual_widget = QWidget()
        central_layout.addWidget(visual_widget)

        visual_layout = QGridLayout()
        visual_widget.setLayout(visual_layout)

        self.plot_area = pg.PlotWidget(name='plot')
        visual_layout.addWidget(self.plot_area, 0, 0, 5, 5)
        self.plot = self.plot_area.plot()
        self.plot.setPen(pg.mkPen(255, 255, 255))
        self.plot_area.setLabel('left', 'Value', units='V')
        self.plot_area.setLabel('bottom', 'Time', units='s')

        box_cont = QGroupBox('continuous acquisition')
        control_layout.addWidget(box_cont)
        box_cont_layout = QGridLayout()
        box_cont.setLayout(box_cont_layout)

        self.start_button = QPushButton('start')
        box_cont_layout.addWidget(self.start_button, 0, 0, 1, 1)
        self.start_button.clicked.connect(self.start_continuous_acquisition)
        self.stop_button = QPushButton('stop')
        box_cont_layout.addWidget(self.stop_button, 0, 1, 1, 1)
        self.stop_button.clicked.connect(self.stop_continuous_acquisition)


        box_finite = QGroupBox('finite acquisition')
        control_layout.addWidget(box_finite)
        box_finite_layout = QGridLayout()
        box_finite.setLayout(box_finite_layout)

        self.iterations_spinbox = QSpinBox()
        box_finite_layout.addWidget(self.iterations_spinbox, 0, 0, 1, 1)
        self.iterations_spinbox.setMinimum(1)
        self.iterations_spinbox.setValue(10)
        self.iterations_spinbox.valueChanged.connect(self.set_iteration_number)
        self.start_finite_button = QPushButton('Go!')
        box_finite_layout.addWidget(self.start_finite_button, 0, 1, 1, 1)
        self.start_finite_button.clicked.connect(self.start_finite_acquisition)

    def setupUi_old(self):
        self.central_widget = QWidget(self)
        self.setCentralWidget(self.central_widget)
        self.central_layout = QHBoxLayout()
        self.central_widget.setLayout(self.central_layout)
        # self.main_layout = QGridLayout(self)
        # self.central_widget.setLayout(self.main_layout)

        self.control_widget = QWidget()
        self.central_layout.addWidget(self.control_widget)
        self.control_layout = QVBoxLayout()
        self.control_widget.setLayout(self.control_layout)
        self.visual_widget = QWidget()
        self.central_layout.addWidget(self.visual_widget)

        self.visual_layout = QGridLayout()
        self.visual_widget.setLayout(self.visual_layout)

        self.plot_area = pg.PlotWidget(name='plot')
        self.visual_layout.addWidget(self.plot_area, 0, 0, 5, 5)
        self.setup_plot_area()

        self.controlbox = QGroupBox('controls')
        self.control_layout.addWidget(self.controlbox)
        self.controlbox_layout = QGridLayout()
        self.controlbox.setLayout(self.controlbox_layout)

        self.start_stop_button = QPushButton('start/stop')
        self.controlbox_layout.addWidget(self.start_stop_button, 0, 0, 1, 1)
        self.start_stop_button.clicked.connect(self.start_stop_timer)
        #
        # self.fit_checkbox = QRadioButton('fit')
        # self.controlbox_layout.addWidget(self.fit_checkbox, 1, 0, 1, 1)
        # self.fit_button = QPushButton('force refit')
        # self.controlbox_layout.addWidget(self.fit_button, 1, 1, 1, 1)
        # self.fit_button.clicked.connect(self.fit_peaks)
        #
        # self.resultsbox = QGroupBox('Fit Results')
        # self.main_layout.addWidget(self.resultsbox, 1, 3, 1, 2)
        # self.resultsbox_layout = QGridLayout()
        # self.resultsbox.setLayout(self.resultsbox_layout)
        #
        # self.fit_results_text = QLabel('Start fitting to show results')
        # self.fit_results_text.setFont(QFont("Times", 8, QFont.Bold))
        # self.resultsbox_layout.addWidget(self.fit_results_text, 0, 0)
        # self.fit_mainresults_text = QLabel('')
        # self.fit_mainresults_text.setFont(QFont("Times", 12, QFont.Bold))
        # self.resultsbox_layout.addWidget(self.fit_mainresults_text, 0, 1)
        #
        # # self.plt_widget = MatplotlibWidget.MatplotlibWidget()
        # # self.main_layout.addWidget(self.plt_widget,0,0,5,5)
        # # self.subplot = self.plt_widget.getFigure().add_subplot(111)

    def make_bins(self, data, n_bins=1000, cutoff=.02):
        dmax, dmin = data[0].max(), data[0].min()
        amp = dmax - dmin
        dmax -= amp * cutoff
        dmin += amp * cutoff
        self.bins = np.linspace(dmin, dmax, n_bins)

    def set_iteration_number(self,n):
        self.finite_iterations = n

    def set_clock_frequency(self, frequency=2):
        self.main_clock.setInterval(1. / frequency)

    def start_stop_timer(self):
        if self.main_clock_running:
            self.main_clock.stop()
            self.main_clock_running = False
            self.status_bar.showMessage('Main Clock Started')
        else:
            self.main_clock.start()
            self.main_clock_running = True
            self.status_bar.showMessage('Main Clock Stopped')

    def on_timer(self):
        shaker_position, signal, n = self.measure()
        self.draw_plot(n, shaker_position)

    def start_continuous_acquisition(self):
        self.streamer_thread = QtCore.QThread()

        self.streamer = Streamer(self.n_samples)
        self.stramer.newData[np.ndarray].connect(self.on_streamer_data)
        self.streamer_thread.started.connect(self.streamer.start_acquisition)
        self.streamer_thread.start()

    def stop_continuous_acquisition(self):
        self.streamer.stop_acquisition()
        self.streamer.kill()

    def start_finite_acquisition(self):
        self.streamer_thread = QtCore.QThread()

        self.streamer = Streamer(self.n_samples,self.finite_iterations)
        self.streamer.newData[np.ndarray].connect(self.on_streamer_data)
        self.streamer.finished.connect(self.stop_finite_acquisition)
        self.streamer_thread.started.connect(self.streamer.start_acquisition)
        self.streamer_thread.start()

    def stop_finite_acquisition(self):
        self.streamer.kill()

    def bin_data(self, data):
        if self.bins is None:
            self.make_bins(data)
        self.binner_thread = QtCore.QThread()
        self.binner = Streamer(self.n_samples)
        self.binner.newData[np.ndarray].connect(self.on_binner_data)
        self.binner_thread.started.connect(self.binner.work)
        self.binner_thread.start()

    def draw_plot(self, xd, yd):
        self.plot.setData(x=xd, y=yd)

    @QtCore.pyqtSlot()
    def on_streamer_data(self, data):
        self.bin_data(data)

    @QtCore.pyqtSlot()
    def on_binner_data(self, data):
        self.draw_plot(self.bins, data)

    def closeEvent(self, event):
        # geometry = self.saveGeometry()
        # self.qsettings.setValue('geometry', geometry)
        super(FastScanMainWindow, self).closeEvent(event)
        print('quitted properly')


class Streamer(QtCore.QObject):
    finished = QtCore.pyqtSignal()
    newData = QtCore.pyqtSignal(np.ndarray)

    # progressChanged = QtCore.pyqtSignal(float)
    # stateChanged = QtCore.pyqtSignal(str)

    def __init__(self, n_samples, iterations=None):
        super().__init__()

        self.n_samples = n_samples
        self.iterations = iterations
        self.data = np.zeros((3, n_samples))

        self.task = nidaqmx.Task()
        self.reader = nidaqmx.stream_readers.AnalogMultiChannelReader(self.in_stream)
        self.task.ai_channels.add_ai_voltage_chan("Dev1/ai0")  # shaker position chanel
        self.task.ai_channels.add_ai_voltage_chan("Dev1/ai1")  # signal chanel
        self.task.ai_channels.add_ai_voltage_chan("Dev1/ai2")  # dark control chanel
        self.task.timing.cfg_samp_clk_timing(1000000, source="/Dev1/PFI0",
                                             active_edge=Edge.RISING,
                                             sample_mode=AcquisitionType.CONTINUOUS)
        self.acquire = False

    @QtCore.pyqtSlot()
    def start_acquisition(self):
        self.acquire = True
        self.task.start()
        if self.iterations is None:
            while self.acquire:
                self.measure()
        else:
            for i in range(self.iterations):
                self.measure()
            self.stop_acquisition()

    @QtCore.pyqtSlot()
    def stop_acquisition(self):
        if self.acquire:
            self.acquire = False
            self.task.stop()
            self.finished.emit()

    def measure(self):
        self.reader.read_many_sample(self.data, number_of_samples_per_channel=self.n_samples)
        self.newData.emit(self.data)
        self.prevData = self.prevData

    @QtCore.pyqtSlot()
    def work(self):
        self.acquire = True

    @QtCore.pyqtSlot()
    def kill(self):
        self.task.close()

    def __exit__(self):
        self.kill()


class Binner(QtCore.QObject):
    def __init__(self, data, bins):
        super().__init__()
        self.data_input = data
        self.bins = bins
        self.data_output = np.zeros_like(bins)
        self.bin_method = bin_dc_multi

    @QtCore.pyqtSlot()
    def work(self):
        chunks = os.cpu_count()
        data_split = np.split(self.data, chunks, axis=1)
        args = []
        for data in data_split:
            args.append((data, self.bins))
        pool = Pool(chunks)
        results = pool.map(self.bin_method, args)
        results = np.array(results)

        binned_signal = []
        normarray = []

        for i in range(8):
            binned_signal.append(results[i, 0, :])
            normarray.append(results[i, 1, :])
        binned_signal = np.nansum(np.array(binned_signal), 0)
        normarray = np.nansum(np.array(normarray), 0)

        self.data_output = binned_signal / normarray
        self.newData.emit(self.data_output)


if __name__ == '__main__':
    main()
